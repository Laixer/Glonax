use std::error::Error as StdError;
use std::ffi::CStr;
use std::fmt;
use std::io;
use std::str;

use libc::{c_char, c_int, size_t};

/// A type for results generated by interacting with serial ports.
///
/// The `Err` type is hard-wired to [`serial_core::Error`](struct.Error.html).
pub type Result<T> = std::result::Result<T, Error>;

/// Categories of errors that can occur when interacting with serial ports.
///
/// This list is intended to grow over time and it is not recommended to exhaustively match against
/// it.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ErrorKind {
    /// The device is not available.
    ///
    /// This could indicate that the device is in use by another process or was disconnected while
    /// performing I/O.
    NoDevice,

    /// A parameter was incorrect.
    InvalidInput,

    /// An I/O error occured.
    ///
    /// The type of I/O error is determined by the inner `io::ErrorKind`.
    Io(io::ErrorKind),
}

/// An error type for serial port operations.
#[derive(Debug)]
pub struct Error {
    kind: ErrorKind,
    description: String,
}

impl Error {
    pub fn new<T: Into<String>>(kind: ErrorKind, description: T) -> Self {
        Error {
            kind,
            description: description.into(),
        }
    }

    /// Returns the corresponding `ErrorKind` for this error.
    pub fn kind(&self) -> ErrorKind {
        self.kind
    }
}

impl fmt::Display for Error {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> std::result::Result<(), fmt::Error> {
        fmt.write_str(&self.description)
    }
}

impl StdError for Error {
    fn description(&self) -> &str {
        &self.description
    }
}

impl From<io::Error> for Error {
    fn from(io_error: io::Error) -> Error {
        Error::new(ErrorKind::Io(io_error.kind()), format!("{}", io_error))
    }
}

pub fn last_os_error() -> Error {
    from_raw_os_error(errno())
}

pub fn from_raw_os_error(errno: i32) -> Error {
    use libc::{
        EACCES, EBUSY, EINTR, EINVAL, EISDIR, ELOOP, ENAMETOOLONG, ENODEV, ENOENT, ENOTDIR, ENXIO,
        EWOULDBLOCK,
    };

    let kind = match errno {
        EBUSY | EISDIR | ELOOP | ENOTDIR | ENOENT | ENODEV | ENXIO | EACCES => ErrorKind::NoDevice,
        EINVAL | ENAMETOOLONG => ErrorKind::InvalidInput,

        EINTR => ErrorKind::Io(io::ErrorKind::Interrupted),
        EWOULDBLOCK => ErrorKind::Io(io::ErrorKind::WouldBlock),
        _ => ErrorKind::Io(io::ErrorKind::Other),
    };

    Error::new(kind, error_string(errno))
}

// the rest of this module is borrowed from libstd

const TMPBUF_SZ: usize = 128;

pub fn errno() -> i32 {
    unsafe fn errno_location() -> *const c_int {
        extern "C" {
            fn __errno_location() -> *const c_int;
        }
        __errno_location()
    }

    unsafe { *errno_location() }
}

pub fn error_string(errno: i32) -> String {
    extern "C" {
        #[link_name = "__xpg_strerror_r"]
        fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: size_t) -> c_int;
    }

    let mut buf = [0 as c_char; TMPBUF_SZ];

    let p = buf.as_mut_ptr();
    unsafe {
        if strerror_r(errno as c_int, p, buf.len() as size_t) < 0 {
            panic!("strerror_r failure");
        }

        let p = p as *const _;
        str::from_utf8(CStr::from_ptr(p).to_bytes())
            .unwrap()
            .to_string()
    }
}
